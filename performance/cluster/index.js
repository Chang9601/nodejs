// // 클러스터의 모든 노예가 스레드 풀에서 하나의 스레드만 사용할 수 있다.
// // 클러스터를 생성할 때마다 모든 개별 노예는 자체 별도의 스레드 풀을 가진다.
// // 일반적으로 생성하는 모든 노예는 연산에 사용할 수 있는 4개의 스레드를 가진다.
// // 이는 클러스터의 전체 스레드의 수를 제한하는 것이 아니라 클러스터의 각 노예가 하나의 스레드만 사용할 수 있도록 제한한다.
// process.env.UV_THREADPOOL_SIZE = 1;

// const cluster = require('cluster');

// // NodeJS를 실행하면 Node는 파일의 내용을 실행하고 클러스터 관리자라고 하는 NodeJS의 복사본을 시작한다.
// // 클러스터 관리자는 항상 isMaster 속성이 true로 설정되어 있다. 하지만 일꾼 인스턴스를 만들기 시작하면 false로 설정된다.
// // 다시 말해, 클러스터 관리자의 경우 isMaster는 true로 모든 워커 인스턴스의 경우 isMaster는 false로 설정되어 있다.
// console.log(cluster.isMaster);

// // index.js 파일을 처음 실행할 때 index.js 파일이 주인 모드에서 실행되고 있으며 if 문의 cluster.fork() 메서드를 호출한다.
// if (cluster.isMaster) {
//   // 노예 수를 컴퓨터의 논리 코어 또는 물리 코어 수 이상으로 늘리면 수확 체감 효과로 시스템의 성능에 부정적인 영향을 미친다.
//   // 일반적으로 클러스터 내의 노예 수를 컴퓨터의 물리 코어 또는 논리 코어 수와 일치시키는 것이 좋다.
//   cluster.fork();
//   cluster.fork();

//   // index.js는 다시 실행되는데 노예 모드에서 실행된다. 만약 파일이 노예 모드라면, else 문에 케이스에 진입하고 서버로 작동한다.
//   // cluster.fork() 메서드를 4번 호출하고 있기에 이는 index.js 파일이 4번 더 실행될 것이며 각각의 경우 isMaster 속성은 false로 설정된다.
// } else {

const express = require('express');
const crypto = require('crypto');

const app = express();

const PORT = 3000;

app.get('/hi', (req, res) => {
  crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
    res.send('안녕!');
  });
});

app.get('/bye', (req, res) => {
  // /hi 주소 호출 후 /bye 호출 시
  // 클러스터를 사용하지 않거나 일꾼 인스턴스가 1개 밖에 없으면 1번째 요청(/hi)이 완료될 때까지 이벤트 루프가 다른 작업을 수행할 수 없기 때문에 대략 5초 정도 기다려야 한다.
  // 하지만 일꾼 인스턴스가 2개 이상이면 개별 서버가 각각 요청을 처리하기 때문에 1번째 요청은 5초 정도가 걸려도 2번째 요청은 0.17초 정도로 굉장히 빠르게 완료된다.

  // 애플리케이션 내에 처리 시간이 오래 걸리는 몇 가지 경로가 있지만 매우 빠른 다른 경로도 있는 경우
  // 클러스터링을 사용하면 여러 인스턴스를 시작할 수 있으며 들어오는 모든 요청을 보다 고르게 처리할 수 있다.
  res.send('잘가!');
});

app.listen(PORT);
// }
