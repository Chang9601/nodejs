/*
  NodeJS의 단일 스레드에서 발생하는 작업 순서.
  1. 프로그램이 초기화된다.
  2. 최상위 코드(콜백 함수 안에 존재하지 않는 코드)가 실행된다.
  3. 듈을 require() 함수로 가져온다.
  4. 이벤트 콜백을 등록한다.
  5. 이벤트 루프를 시작한다.
*/

/*
  이벤트 루프.
  콜백 함수 내부의 모든 애플리케이션 코드는 이벤트 루프에서 실행되고 무거운 작업은 스레드 풀로 전달된다.
  NodeJS는 이벤트 기반 아키텍처를 사용한다.
  즉, 애플리케이션이 서버에서 HTTP 요청을 수신하거나 타이머가 만료되거나 파일 읽기가 완료되며 이벤트를 발생시키고 이벤트 루프가 이벤트를 수신하고 각 이벤트에 연결된 콜백 함수를 호출한다. 
  요약하면, 이벤트 루프가 조정(orchestration) 작업을 수행한다고 말할 수 있다. 다시말해, 이벤트를 수신하고 해당 콜백 함수를 호출하고 비용이 많이 드는 작업을 스레드 풀로 전달한다.
  이벤트 루프에는 여러 단계가 있으며 각 단계를 콜백 큐를 가진다.
  콜백 큐에는 이벤트 루프가 받는 이벤트에서 온 콜백이 있다.

  1. 만료된 타이머의 콜백(e.g., setTimeout() 함수)
     만료된 타이머의 콜백 함수가 있다면 이벤트 루프에 의해 가장 먼저 처리된다.
     만약 다른 단계가 처리되는 동안에 타이머가 나중에 만료된다면 해당 타이머의 콜백은 이벤트 루프가 다시 1번 단계로 돌아올 때까지 호출되지 않는다.
     이는 모든 네 가지 단계에서 동일하게 작동한다. 각 콜백 큐의 콜백은 하나씩 처리되며 콜백 큐에 더 이상 없을 때까지 그리고 그때에만 이벤트 루프가 다음 단계로 진입한다.

  2. I/O 폴링과 콜백
     폴링이란 처리할 준비가 된 새로운 I/O 이벤트를 찾는 것을 의미하며 이벤트를 콜백 큐에 넣는 것이다.
     NodeJS 애플리케이션의 맥락에서 I/O는 주로 네트워크 및 파일 접근과 관련된 것을 의미한다.

  3. setImmediate 콜백
     setImmediate는 I/O 폴링 및 콜백 단계 이후에 바로 콜백을 처리하고 싶을 때 사용할 수 있는 특별한 종류의 타이머이다.

  4. close 콜백
     모든 종료 이벤트가 처리된다.

  다음 두 큐는 처리해야 할 콜백이 있다면 전체 루프가 완료될 때까지 기다리지 않고 현재 이벤트 루프 단계가 끝난 후에 즉시 실행된다.
  다시 말해, 앞의 4가지 단계 각각 이후에 이 두 큐 중 하나에 콜백이 있다면 즉시 실행된다.

  1. process.nextTick() 큐
     현재 이벤트 루프 단계 이후에 특정 콜백을 실행해야 할 때 사용하는 함수입니다.
     이는 setImmediate() 함수와 유사하지만 setImmediate() 함수는 I/O 폴링과 콜백 단계 이후에만 실행된다는 차이가 있다.

  2. 마이크로태스크 큐
     해결된 프로미스들을 처리한다.

  이벤트 루프가 틱(이벤트 루프 순회)을 계속 진행해야 할지 아니면 애플리케이션을 종료해야 할지를 결정하는 방법.
  NodeJS는 백그라운드에서 여전히 실행 중인 타이머나 I/O 작업이 있는지 확인하고 없다면 애플리케이션을 종료한다.
  그러나 보류 중인 타이머나 I/O 작업이 있는 경우 이벤트 루프를 계속 실행하고 다음 틱으로 이동한다.     
*/

/*
  스레드 풀.
  단일 스레드를 차단할 수 있는 비용이 많이 들어가는 작업을 이벤트 루프에서 실행되지 않으며 스레드 풀로 작업을 자동으로 전달한다. 
  이벤트 루프처럼 libuv 라이브러리가 제공하는 스레드 풀은 메인 스레드와 완전히 분리되어 있으며 기본적으로 4개 스레드를 제공한다(최대 128개의 스레드까지 구성할 수 있다). 
  어떤 작업이 스레드 풀로 가고 어떤 작업이 그렇지 않을지를 결정하는 것은 개발자가 아니다. 
  스레드 풀로 전달되는 무거운 작업은 파일 처리, 비밀번호 캐싱과 같은 암호화, 압축 작업 및 DNS 조회 작업이다. 
  NodeJS는 이러한 작업을 자동으로 스레드 풀로 전달하여 이벤트 루프를 차단하지 않도록 처리한다.
*/

const fs = require('fs');
const crypto = require('crypto');

const start = Date.now();
process.env.UV_THREADPOOL_SIZE = 4;

// 3개의 로그는 특정한 순서로 나오지 않는데 이벤트 루프 내에서 실행되지 않기 때문이다(코드가 콜백 함수 내에서 실행되지 않기 때문이다.).
setTimeout(() => console.log('setTimeout 1 종료.'), 0);
setImmediate(() => console.log('setImmediate 1 종료.'));

fs.readFile('file.txt', () => {
  console.log('입출력 종료.');

  /*
    이벤트 루프는 I/O 폴링과 콜백 단계에서 기다린다. 따라서 콜백 큐가 비어 있고 타이머만 있는 경우, 이벤트 루프는 만료된 타이머가 발생할 때까지 I/O 폴링과 콜백 단계에서 기다린다.
    그러나 setImmediate를 사용하여 콜백을 예약한 경우 해당 콜백은 I/O 폴링과 콜백 단계 이후에 즉시 실행되며 그 전에 만료된 타이머가 있다면 만료된 타이머보다 먼저 실행된다.
    타이머가 즉시 만료되지만 이벤트 루프는 I/O 폴링과 콜백 단계에서 일시 중지한다. 그래서 setImmediate 콜백이 먼저 실행된다.
  */
  setTimeout(() => console.log('setTimeout 2 종료.'), 0);
  setTimeout(() => console.log('setTimeout 3 종료.'), 2000);
  setImmediate(() => console.log('setImmediate 2 종료.'));

  // 전체 틱이 끝난 다음이 아니라 각 단계 후에 실행된다.
  process.nextTick(() => console.log('process.nextTick 종료.'));

  /*
    스레드 풀의 크기는 4개이기 때문에 동시에 4개의 스레드가 작업을 수행한다.
    따라서, 4개의 비밀번호 암호화가 거의 동시에 발생하고 거의 동일한 시간이 소요되는 이유이다.
    만약 pbkdf2Sync() 함수를 사용하면 코드가 더 이상 이벤트 루프에서 실행되지 않기 때문에 스레드 풀로 할당되지 않는다
    다시 말해, 코드가 동기적으로 실행되기 때문에 모든 타이머가 비밀번호 암호화가 일어난 후에 발생한다. 심지어 process.nextTick() 함수와 setImmediate() 함수도 마찬가지다.
  */
  crypto.pbkdf2('password', 'salt', 100000, 1024, 'sha512', () => {
    const finish = Date.now();
    console.log(finish - start, '비밀번호 암호화.');
  });
  crypto.pbkdf2('password', 'salt', 100000, 1024, 'sha512', () => {
    const finish = Date.now();
    console.log(finish - start, '비밀번호 암호화.');
  });
  crypto.pbkdf2('password', 'salt', 100000, 1024, 'sha512', () => {
    const finish = Date.now();
    console.log(finish - start, '비밀번호 암호화.');
  });
  crypto.pbkdf2('password', 'salt', 100000, 1024, 'sha512', () => {
    const finish = Date.now();
    console.log(finish - start, '비밀번호 암호화.');
  });
});

console.log('최상위 수준 코드.');
