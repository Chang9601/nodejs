// libuv 라이브러리가 스레드 풀을 생성할 때 생성할 스레드의 개수를 명시한다.
// OS 스케줄러가 사용 가능한 코어로 작업을 어떻게 조절할지 결정한다.
// 따라서 다섯 개의 스레드는거의 동시에 거의 동일한 양의 CPU 시간을 얻는다.
// process.env.UV_THREADPOOL_SIZE = 8;

const crypto = require('crypto');
const os = require('os');

const numCores = os.cpus().length;

console.log(`CPU 코어 개수: ${numCores}`); // 8개.

// pbkdf2() 함수 호출을 시작한 시간을 기록하는 변수.
const start = Date.now();

crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
  // 콜백함수가 호출될 때 새로운 현재 시간에서 이전 시간을 빼서 해시 값을 계산하는데 걸린 시간을 밀리초 단위로 출력한다.
  console.log(`1: ${Date.now() - start}`); // 대략 1.2초
});

// 1. 파일을 실행하는 즉시 두 함수는 거의 동시에 실행된다.
// 2. start 변수가 그대로이기 때문에 각 로그는 프로그램을 시작한 시점부터 각 함수 호출이 끝날 때까지 걸린 정확한 시간이다.
crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
  // 걸린 시간이 대략 1.2초로 거의 비슷하다.
  // 스레드는 CPU에 일련의 선형적인 명령을 제공하기에 CPU는 제시한 순서대로 실행한다.
  // 로그에서 pbkdf2() 함수를 호출하면 대략 1.2초가 소요된다. 따라서 만약 NodeJS가 진짜로 단일 스레드라면 두 번의 호출로 전체 프로세스가 총 2.4초 걸려야 한다.
  // 다시 말해서, 프로그램이 시작하면 0초에서 시작할 것이기에 1번째 호출은 1.2초 소요될 것이고 1번째 호출 완료 후 2번째 호출이 시작하면 2.4초에는 2번째 호출이 완료되어야 한다.
  console.log(`2: ${Date.now() - start}`);
});

// 1번째, 2번째, 3번째, 4번째 호출은 대략 1.3초에서 1.4초가 걸리지만 5번째 호출은 대략 2.6초가 걸린다.
// 왜 1초 정도의 차이가 발생할까?
// libuv 라이브러리의 주요 책임은 NodeJS가 운영체제의 기능을 사용할 수 있도록 하는 것이다.
// 하지만 libuv 라이브러리는 일부 NodeJS 표준 라이브러리의 함수 호출에 관련해서 다른 책임을 갖고 있다.
// NodeJS의 C++ 측면과 libuv 라이브러리는 비용이 많이 드는 일부 NodeJS 표준 라이브러리의 함수의 연산을 이벤트 루프 외부에서 수행한다.
// 즉, 스레드 풀을 사용해 연산 집약적인 작업을 실행한다. 기본적으로 libuv 라이브러리는 스레드 풀에서 4개의 스레드를 생성한다.
// NodeJS는 완전히 단일 스레드가 아니다! 왜냐하면 연산 집약적인 작업을 수행하는 데 사용되는 다른 스레드가 있기 때문이다!
// 만약 이벤트 루프가 연산 집약적인 작업을 수행해야 한다면 프로그램은 pbkdf2() 함수를 실행하는 동안 아무것도 할 수 없다.
crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
  console.log(`3: ${Date.now() - start}`); // 대략 1.3초.
});

crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
  console.log(`4: ${Date.now() - start}`); // 대략 1.3초.
});

crypto.pbkdf2('1234', 'salt', 100000, 512, 'sha512', () => {
  console.log(`5: ${Date.now() - start}`); // 대략 2.6초.
});
